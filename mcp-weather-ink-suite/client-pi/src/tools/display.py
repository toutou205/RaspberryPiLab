"""
MCP Tool for displaying weather information on E-Ink display.
Defines the tool interface and data validation.
"""
import logging
from typing import Optional
from mcp.server.fastmcp import FastMCP
from pydantic import BaseModel, Field, field_validator
from services.drawing import generate_weather_image, split_image_for_epd, WMO_MAPPING
from services.hardware import EPDService

logger = logging.getLogger(__name__)


class WeatherDisplayInput(BaseModel):
    """
    Input data model for weather display tool.
    
    All fields are validated according to the requirements:
    - Country code: max 3 characters
    - City name: required string
    - Temperature: float value
    - AQI: integer between 0 and 1000
    - PM2.5: positive float
    - Weather code: must be valid WMO code
    - Advice message: max 32 characters
    """
    
    country_code: str = Field(
        ...,
        max_length=3,
        description="ISO Country Code (e.g., CHN, US, GBR)"
    )
    
    city_name: str = Field(
        ...,
        description="City Name (e.g., Chongqing, Portland)"
    )
    
    timestamp: str = Field(
        ...,
        description="Formatted timestamp: yy/mm/dd hh:mm Week (e.g., 25/12/29 13:00 Mon)"
    )
    
    weather_code: int = Field(
        ...,
        description="WMO Weather Code from Open-Meteo (must be valid code)"
    )
    
    weather_desc: str = Field(
        ...,
        description="Weather description text (e.g., 'Moderate Rain', 'Clear sky')"
    )
    
    temperature: float = Field(
        ...,
        description="Current temperature in Celsius"
    )
    
    aqi: int = Field(
        ...,
        gt=0,
        lt=1000,
        description="Air Quality Index (must be between 0 and 1000)"
    )
    
    pm25: float = Field(
        ...,
        gt=0,
        description="PM2.5 Concentration value (must be positive)"
    )
    
    advice_msg: str = Field(
        ...,
        max_length=32,
        description="Short health advice generated by LLM (max 32 characters including punctuation)"
    )

    @field_validator('weather_code')
    @classmethod
    def validate_wmo_code(cls, v: int) -> int:
        """
        Validate that the weather code is a known WMO code.
        
        If code is not in mapping, it will fall back to 999.png (Unknown) during rendering.
        """
        if v not in WMO_MAPPING and v != 999:
            logger.warning(f"Weather code {v} not in WMO_MAPPING, will use fallback icon")
        return v

    @field_validator('country_code')
    @classmethod
    def validate_country_code(cls, v: str) -> str:
        """Validate country code format."""
        v = v.strip().upper()
        if len(v) > 3:
            raise ValueError("Country code must be 3 characters or less")
        return v

    @field_validator('city_name')
    @classmethod
    def validate_city_name(cls, v: str) -> str:
        """Sanitize city name."""
        return v.strip()

    @field_validator('advice_msg')
    @classmethod
    def validate_advice_msg(cls, v: str) -> str:
        """Ensure advice message is within length limit."""
        v = v.strip()
        if len(v) > 32:
            raise ValueError(f"Advice message must be 32 characters or less (got {len(v)})")
        return v


def register_tools(mcp: FastMCP) -> None:
    """
    Register MCP tools with the server instance.
    
    Args:
        mcp: FastMCP server instance to register tools with
    """
    epd_service = EPDService()

    @mcp.tool()
    async def display_weather_info(data: WeatherDisplayInput) -> str:
        """
        Render weather and AQI information to the E-Ink display on Raspberry Pi.
        
        This tool generates a 3-color (Black/White/Red) UI based on AQI levels:
        - 0-100: Normal (white background, black text)
        - 101-200: Warning (white background, red highlights)
        - >200: Alert (red background, white text)
        
        The tool accepts validated weather and air quality data, generates the display
        image, converts it to E-Paper format, and refreshes the hardware display.
        
        Args:
            data: WeatherDisplayInput object containing all required display data
            
        Returns:
            Success message string or error description
        """
        try:
            logger.info("========== STARTING TOOL EXECUTION: display_weather_info ==========")
            logger.info(f"Display request received for {data.city_name}, AQI: {data.aqi}")
            
            # 1. Generate RGB image
            data_dict = data.model_dump()
            rgb_image = generate_weather_image(data_dict)
            
            # Optional: Save debug image
            try:
                rgb_image.save("debug_rgb_display.png")
                logger.debug("Debug RGB image saved: debug_rgb_display.png")
            except Exception as e:
                logger.warning(f"Failed to save debug image: {e}")
            
            # 2. Convert to E-Paper dual-channel format
            image_black, image_red = split_image_for_epd(rgb_image)
            
            # Optional: Save debug channel images
            try:
                image_black.save("debug_black_display.png")
                image_red.save("debug_red_display.png")
                logger.debug("Debug channel images saved")
            except Exception as e:
                logger.warning(f"Failed to save debug channel images: {e}")
            
            # 3. Display on hardware
            epd_service.display(image_black, image_red)
            
            return (
                f"Successfully displayed weather for {data.city_name}. "
                f"AQI: {data.aqi} ({data.weather_desc}, {data.temperature}Â°C)"
            )
        
        except ValueError as e:
            error_msg = f"Validation error: {str(e)}"
            logger.error(error_msg)
            return error_msg
        except Exception as e:
            error_msg = f"Error displaying image: {str(e)}"
            logger.error(error_msg, exc_info=True)
            return error_msg

